---
title: "String Solutions"
author: "PLSC 31101"
date: "Fall 2020"
output: html_document
---

```{r message = FALSE}
library(tidyverse)
library(stringr)
```

## 1. Strings

#### Challenge 1. {-}

In code that does not use `stringr`, you will often see `paste()` and `paste0()`. What is the difference between the two functions? What `stringr` function are they equivalent to? How do the functions differ in their handling of `NA`?

- `paste()` adds a space separator by default; `paste0()` does not. 
- The `stringr` equivalent to `paste()` is `str_c()`, as in `str_c("hey", "you", sep = " ")`. 
- `paste()` and `paste0()` will convert `NA`s to characters; `str_c()` will not.
    
#### Challenge 2. {-}

In your own words, describe the difference between the `sep` and `collapse` arguments to `str_c()`.

- `sep = ","` inserts a "," between vector arguments. The output is a vector.
- `collapse = ","` will combine input vectors into a single string. The output is a single string (i.e., a vector of length = 1).

```{r}
vec1 <- c("a", "b", "c")
vec2 <- c(1, 2, 3)

str_c(vec1, vec2, sep = ".")
# c("a.1" , "b.2" , "c.3")

str_c(vec1, vec2, collapse = ".")
# "a1.b2.c3"
```


#### Challenge 3. {-}

Use `str_length()` and `str_sub()` to extract the middle character from 
a string. What will you do if the string has an even number of characters?

```{r}
# For odd cases
x <- "lemon"
str_sub(x,
        start = ceiling(str_length(x) / 2 ), 
        end = ceiling(str_length(x) / 2))

# For both odd and even cases
x <- "pies"
str_sub(x,
        start = ifelse(str_length(x) %% 2 == 0, 
                       floor(str_length(x) / 2), 
                       ceiling(str_length(x) / 2 )), 
        end = floor(str_length(x) / 2) + 1)
```


#### Challenge 4. {-}

What does `str_trim()` do? What is the opposite of `str_trim()`?

- `str_trim()` removes whitespace from the start and the end of the string.
- `str_pad()` adds whitespace to the start and the end of the string.


## 2. Regex

#### Challenge 1. {-}

Create regular expressions to find all words that:

  1. Start with a vowel.

```{r}
str_view(x, "^[aeiou]")
```

  
  2. Only contain consonants. (Hint: Think about matching 
         "not"-vowels.)
  
```{r}
str_view(x, "[^aeiou]+")
```

  3. End with `ed`, but not with `eed`.
  
```{r}
str_view(x, "[^e]ed$+")
```
      
  4. End with `ing` or `ise`.

```{r}
str_view(x, "(ing|ise)$+")
```

## 3. Tools

#### Challenge 1. {-}

For each of the following challenges, try solving it by using both a single regular expression and a combination of multiple `str_detect()` calls.
    
    1.  Find all words that start or end with `x`.
    
    2.  Find all words that start with a vowel and end with a consonant.
    
```{r}
df <- data.frame(
  i = seq_along(words),
  word = words
)

#1. Regex
str_view(df$word, "^x|x$")

#1. str_detect
df %>% 
    filter(str_detect(word, "^x") | str_detect(word, "x$"))

#2. Regex
str_view(df$word, "^[aeiou].+[^aeiou]$")

#2. str_detect
df %>% 
    filter(str_detect(word, "^[aeiou]") & str_detect(word, "[^aeiou]$"))
```

#### Challenge 2. {-}

In the previous example, you might have noticed that the regular expression matched "flickered", which is not a color. Modify the regex to fix the problem.

```{r}
has_color <- str_subset(sentences, "[^\\w](red|orange|yellow|green|blue|purple)[^\\w]")
head(has_color)
```


#### Challenge 3. {-}

  1.  Split up a string like `"apples, pears, and bananas"` into individual
      components.
      
```{r}
fruit <- "apples, pears, and bananas"
str_split(fruit, ", ")
#question - need to remove "and" here for "and bananas"? or purpose just to get them to split with the comma?
```

      
  2.  What does splitting with an empty string (`""`) do? Experiment, and
      then read the documentation.
      
```{r}
str_split(fruit, "")

?str_split
```

In the documentation for `str_split`, it says "An empty pattern, "", is equivalent to boundary("character")." So by including an empty string (`""`), the function will automatically assume you want to split after every character in the string.
